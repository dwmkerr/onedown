{"version":3,"sources":["crossword.js","crossworddom.js"],"names":["CrosswordsJS","buildCellArray2D","crossword","x","width","y","height","array","Array","i","j","Crossword","crosswordDefinition","Error","this","acrossClues","downClues","cells","undefined","clueDefinitions","concat","c","length","clueDefinition","across","clueModel","number","code","answer","totalLength","clue","push","letter","cell","light","acrossClue","clueLabel","window","document","removeClass","element","className","expression","RegExp","replace","addClass","CellMap","map","CrosswordDOM","parentElement","container","createElement","row","appendChild","cellElement","_createCellDOM","cellMap","add","crosswordElement","prototype","getCellElement","getCell","removeCrosswordCells","splice","selectClue","currentClue","_updateDOM","focus","_stateChange","destroy","removeChild","onStateChanged","message","data","eventHandler","self","inputElement","maxLength","value","innerHTML","addEventListener","event","target","parentNode","down","downClue","downClueLetterIndex","acrossClueLetterIndex","keyCode","preventDefault","currentIndex","previousIndex","querySelector","searchClues","newClue","shiftKey","setLetter","source","index","newLetter","sourceNormalised","result","seek","Math","max","key","String","fromCharCode","nextIndex","activeClue"],"mappings":"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","file":"crosswords.min.js","sourcesContent":["var CrosswordsJS = (function(CrosswordsJS, window, document) {\r\n\r\n  'use strict';\r\n\r\n  function buildCellArray2D(crossword) {\r\n    var x = crossword.width;\r\n    var y = crossword.height;\r\n    var array = new Array(x);\r\n    for(var i=0; i<y; i++) {\r\n      array[i] = new Array(y);\r\n      for(var j=0; j<y; j++) {\r\n        array[i][j] = {\r\n          crossword: crossword,\r\n          x: i,\r\n          y: j\r\n        };\r\n      }\r\n    }\r\n    return array;\r\n  }\r\n\r\n  //  The crossword class. When a crossword is built from a definition\r\n  //  and options, this is the object which is returned.\r\n  function Crossword(crosswordDefinition) {\r\n\r\n    if(!crosswordDefinition) {\r\n      throw new Error(\"The Crossword must be initialised with a crossword definition.\");\r\n    }\r\n  \r\n    //  Set up some data we'll store in the class.\r\n    this.width = crosswordDefinition.width;\r\n    this.height = crosswordDefinition.height;\r\n    this.acrossClues = [];\r\n    this.downClues = [];\r\n    this.cells = buildCellArray2D(this);\r\n\r\n    //  Validate the bounds.\r\n    if(this.width === undefined || this.width === null || this.width < 0 ||\r\n      this.height === undefined || this.height === null || this.height < 0) {\r\n      throw new Error(\"The crossword bounds are invalid.\");\r\n    }\r\n\r\n    //  We're going to go through the across clues, then the down clues.\r\n    var clueDefinitions = crosswordDefinition.acrossClues.concat(crosswordDefinition.downClues);\r\n    for(var c = 0; c < clueDefinitions.length; c++) {\r\n    \r\n      //  Grab the clue and build a flag letting us know if we're across or down.\r\n      var clueDefinition = clueDefinitions[c];\r\n      var across = c < crosswordDefinition.acrossClues.length;\r\n    \r\n      //  Create a model for the clue.\r\n      var clueModel = {\r\n        number: clueDefinition.number,\r\n        code: clueDefinition.number + (across ? \"a\" : \"d\"),\r\n        answer: clueDefinition.answer,\r\n        x: clueDefinition.x - 1,    //  Definitions are 1 based, models are more useful 0 based.\r\n        y: clueDefinition.y - 1,\r\n        across: across,\r\n        length: [],\r\n        totalLength: 0,\r\n        clue: clueDefinition.clue,\r\n        cells: []\r\n      };\r\n      this[across ? 'acrossClues' : 'downClues'].push(clueModel);\r\n\r\n      //  The clue position must be in the bounds.\r\n      if(clueModel.x < 0 || clueModel.x >= this.width || clueModel.y < 0 || clueModel.y >= this.height) {\r\n        throw new Error(\"Clue \" + clueModel.code + \" doesn't start in the bounds.\");\r\n      }\r\n\r\n      //  Copy over the clue definition length into the model,\r\n      //  also keeping track of the total length.\r\n      for(var i = 0; i < clueDefinition.length.length; i++) {\r\n        clueModel.length.push(clueDefinition.length[i]);\r\n        clueModel.totalLength += clueDefinition.length[i];\r\n      }\r\n\r\n      //  Make sure the clue is not too long.\r\n      if(across) {\r\n        if((clueModel.x + clueModel.totalLength) > this.width) {\r\n          throw new Error(\"Clue \" + clueModel.code + \" exceeds horizontal bounds.\");\r\n        }\r\n      } else {\r\n        if((clueModel.y + clueModel.totalLength) > this.height) {\r\n          throw new Error(\"Clue \" + clueModel.code + \" exceeds vertical bounds.\");\r\n        }\r\n      }\r\n\r\n      //  We can now mark the cells as light. If the clue has \r\n      //  an answer (which is optional), we can validate it \r\n      //  is coherent.\r\n      var x = clueModel.x;\r\n      var y = clueModel.y;\r\n      for(var letter = 0; letter < clueModel.totalLength; letter++) {\r\n        var cell = this.cells[x][y];\r\n        cell.light = true;\r\n        cell[across ? 'acrossClue' : 'downClue'] = clueModel;\r\n        cell[across ? 'acrossClueLetterIndex' : 'downClueLetterIndex'] = letter;\r\n        clueModel.cells.push(cell);\r\n\r\n        //  If the clue has an answer we set it in the cell...\r\n        if(clueModel.answer) {\r\n\r\n          //  ...but only if it is not different to an existing answer.\r\n          if(cell.answer !== undefined && cell.answer !== clueModel.answer[letter]) {\r\n            throw new Error(\"Clue \" + clueModel.code + \" answer at (\" + (x + 1) + \", \" + (y + 1) + \") is not coherent with previous clue (\" + cell.acrossClue.code + \") answer.\");\r\n          }\r\n          cell.answer = clueModel.answer[letter];\r\n        }\r\n\r\n        if(letter === 0) {\r\n          if(cell.clueLabel && cell.clueLabel !== clueModel.number) {\r\n            throw new Error(\"Clue \" + clueModel.code + \" has a label which is inconsistent with another clue (\" + cell.acrossClue.code + \").\");\r\n          }\r\n          cell.clueLabel = clueModel.number;\r\n        }\r\n\r\n        if(across) {\r\n          x++;\r\n        } else {\r\n          y++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  //  Define our public API.\r\n  CrosswordsJS.Crossword = Crossword;\r\n  return CrosswordsJS;\r\n\r\n})(CrosswordsJS || {}, window, document);","var CrosswordsJS = (function(CrosswordsJS, window, document) {\r\n\r\n  'use strict';\r\n\r\n  //  Lightweight helper functions.\r\n  function removeClass(element, className) {\r\n    var expression = new RegExp(\"(?:^|\\\\s)\" + className + \"(?!\\\\S)\", \"g\");\r\n    element.className = element.className.replace(expression, '');\r\n  }\r\n  function addClass(element, className) {\r\n    element.className += \" \" + className;\r\n  }\r\n\r\n  //  Internally used map of Crossword model data to DOM elements.\r\n  function CellMap() {\r\n    this.map = [];\r\n  }\r\n\r\n  //  Adds a Cell <-> Cell Element mapping.\r\n  CellMap.prototype.add = function(cell, cellElement) {\r\n    this.map.push({\r\n      cell: cell,\r\n      cellElement: cellElement\r\n    });\r\n  };\r\n\r\n  //  Gets the DOM element for a cell.\r\n  CellMap.prototype.getCellElement = function(cell) {\r\n    for(var i=0; i<this.map.length; i++) {\r\n      if(this.map[i].cell === cell) { \r\n        return this.map[i].cellElement;\r\n      }\r\n    }\r\n    return null;\r\n  };\r\n\r\n  //  Gets the cell for a DOM element.\r\n  CellMap.prototype.getCell = function(cellElement) {\r\n    for(var i=0; i<this.map.length; i++) {\r\n      if(this.map[i].cellElement === cellElement) { \r\n        return this.map[i].cell;\r\n      }\r\n    }\r\n    return null;\r\n  };\r\n\r\n\r\n  //  Removes entries for a crossword.\r\n  CellMap.prototype.removeCrosswordCells = function removeCrosswordCells(crossword) {\r\n    for(var i=0; i<this.map.length; i++) {\r\n      if(this.map[i].cell.crossword === crossword) { \r\n        this.map.splice(i, 1);\r\n      }\r\n    }\r\n  };\r\n\r\n  var getCellElementData = function getCellElementData(cellElement) {\r\n    for(var i = 0; i < cellMap.length; i++) {\r\n      if(cellMap[i].cellElement === cellElement) {\r\n        return cellMap[i];\r\n      }\r\n    }\r\n    return null;\r\n  };\r\n\r\n  //  Creates the DOM representation of a Crossword.\r\n  function CrosswordDOM(crossword, parentElement) {\r\n\r\n    this.crossword = crossword;\r\n    this.parentElement = parentElement;\r\n\r\n    //  Now build the DOM for the crossword.\r\n    var container = document.createElement('div');\r\n    container.className = \"crossword\";\r\n\r\n    //  Create each cell.\r\n    for(var y = 0; y < crossword.height; y++) {\r\n\r\n      var row = document.createElement('div');\r\n      row.className = \"cwrow\";\r\n      container.appendChild(row);\r\n\r\n      for(var x = 0; x < crossword.width; x++) {\r\n\r\n        var cell = crossword.cells[x][y];\r\n\r\n        //  Build the cell element and add it to the row.\r\n        var cellElement = this._createCellDOM(cell);\r\n        row.appendChild(cellElement);\r\n\r\n        //  Update the map of cells\r\n        cellMap.add(cell, cellElement);\r\n\r\n      }\r\n\r\n    }\r\n\r\n    parentElement.appendChild(container);\r\n    this.crosswordElement = container;\r\n  }\r\n\r\n  //  Selects a clue.\r\n  CrosswordDOM.prototype.selectClue = function selectClue(clue) {\r\n    this.currentClue = clue;\r\n    this._updateDOM();\r\n    cellMap.getCellElement(clue.cells[0]).focus();\r\n    this._stateChange(\"clueSelected\");\r\n  };\r\n\r\n  //  Completely cleans up the crossword.\r\n  CrosswordDOM.prototype.destroy = function destroy() {\r\n    \r\n    //  Clear the map, DOM and state change handler.\r\n    cellMap.removeCrosswordCells(this.crossword);\r\n    this.parentElement.removeChild(this.crosswordElement);\r\n    this.onStateChanged = null;\r\n\r\n  };\r\n\r\n  //  Sends a state change message.\r\n  CrosswordDOM.prototype._stateChange = function _stateChange(message, data) {\r\n\r\n    var eventHandler = this.onStateChanged;\r\n    if(!eventHandler) {\r\n      return;\r\n    }\r\n\r\n    //  Send the message.\r\n    eventHandler({\r\n      message: message,\r\n      data: data\r\n    });\r\n\r\n  };\r\n\r\n  //  Creates DOM for a cell.\r\n  CrosswordDOM.prototype._createCellDOM = function _createCellDOM(cell) {\r\n\r\n    var self = this;\r\n    var cellElement = document.createElement('div');\r\n    cellElement.className = \"cwcell\";\r\n    cell.cellElement = cellElement;\r\n\r\n    //  Add a class.\r\n    cellElement.className += cell.light ? \" light\" : \" dark\";\r\n\r\n    //  If the cell is dark, we are done.\r\n    if(!cell.light) {\r\n      return cellElement;\r\n    }\r\n\r\n    //  Light cells also need an input.\r\n    var inputElement = document.createElement('input');\r\n    inputElement.maxLength = 1;\r\n    if(cell.answer) inputElement.value = cell.answer;\r\n    cellElement.appendChild(inputElement);\r\n\r\n    //  We may need to add a clue label.\r\n    if(cell.clueLabel) {\r\n      var clueLabel = document.createElement('div');\r\n      clueLabel.className = \"cwcluelabel\";\r\n      clueLabel.innerHTML = cell.clueLabel;\r\n      cellElement.appendChild(clueLabel);\r\n    }\r\n\r\n    //  Listen for focus events.\r\n    inputElement.addEventListener(\"focus\", function(event) {\r\n\r\n      //  Get the cell data.\r\n      var cellElement = event.target.parentNode;\r\n      var cell = cellMap.getCell(cellElement);\r\n      var crossword = cell.crossword;\r\n      var across = cell.acrossClue;\r\n      var down = cell.downClue;\r\n\r\n      //  If we have clicked somewhere which is part of the current clue, we\r\n      //  will not need to change it (we won't toggle either).\r\n      if(self.currentClue && \r\n         (self.currentClue === across ||\r\n          self.currentClue === down)) {\r\n        return;\r\n      }\r\n\r\n      //  If we have an across clue XOR a down clue, pick the one we have.\r\n      if( (across && !down) || (!across && down) ) {\r\n        self.currentClue = across || down;\r\n      } else {\r\n        //  We've got across AND down. Prefer across, unless we've on the \r\n        //  first letter of a down clue only\r\n        self.currentClue = cell.downClueLetterIndex === 0 && cell.acrossClueLetterIndex !== 0 ? down : across;     \r\n      }\r\n\r\n      //  Update the DOM, inform of state change.\r\n      self._updateDOM();\r\n      self._stateChange(\"clueSelected\");\r\n      \r\n    });\r\n\r\n    //  Listen for keydown events.\r\n    cellElement.addEventListener(\"keydown\", function(event) {\r\n\r\n      if(event.keyCode === 8) { // backspace\r\n          \r\n        //  Blat the contents of the cell. No need to process the backspace.\r\n        event.preventDefault();\r\n        event.target.value = \"\";\r\n\r\n        //  Try and move to the previous cell of the clue.\r\n        var cellElement = event.target.parentNode;\r\n        var cell = cellMap.getCell(cellElement);\r\n        var currentIndex = cell.acrossClue === self.currentClue ? cell.acrossClueLetterIndex : cell.downClueLetterIndex;\r\n        var previousIndex = currentIndex - 1;\r\n        if(previousIndex >= 0) {\r\n          self.currentClue.cells[previousIndex].cellElement.querySelector('input').focus();\r\n        }\r\n\r\n      } else if(event.keyCode === 9) { // tab\r\n\r\n        //  We don't want default behaviour.\r\n        event.preventDefault();\r\n\r\n        //  Get the cell element and cell data.\r\n        var cellElement = event.target.parentNode;\r\n        var cell = cellMap.getCell(cellElement);\r\n        var crossword = cell.crossword;\r\n        var clue = self.currentClue;\r\n\r\n        //  Get the next clue.\r\n        var searchClues = clue.across ? crossword.acrossClues : crossword.downClues;\r\n        for(var i=0; i<searchClues.length; i++) {\r\n          if(clue === searchClues[i]) {\r\n            var newClue = null;\r\n            if(event.shiftKey) {\r\n              if(i > 0) {\r\n                newClue = searchClues[i-1];\r\n              } else {\r\n                newClue = clue.across ? crossword.downClues[crossword.downClues.length-1] : crossword.acrossClues[crossword.acrossClues.length-1];\r\n              }\r\n            } else {\r\n              if(i < (searchClues.length - 1)) {\r\n                newClue = searchClues[i+1];\r\n              } else {\r\n                newClue = clue.across ? crossword.downClues[0] : crossword.acrossClues[0];\r\n              }\r\n            }\r\n            //  Select the new clue.\r\n            self.currentClue = newClue;\r\n            self._updateDOM();\r\n            cellMap.getCellElement(newClue.cells[0]).querySelector('input').focus();\r\n            break;\r\n          }\r\n        }\r\n\r\n      } else if (event.keyCode === 13) { // enter\r\n\r\n        //  We don't want default behaviour.\r\n        event.preventDefault();\r\n\r\n        //  Get the cell element and cell data.\r\n        var cellElement = event.target.parentNode;\r\n        var cell = cellMap.getCell(cellElement);\r\n        var crossword = cell.crossword;\r\n\r\n        //  If we are in a cell with an across clue AND down clue, swap the\r\n        //  selected one.\r\n        if(cell.acrossClue && cell.downClue) {\r\n          self.currentClue = cell.acrossClue === self.currentClue ? cell.downClue : cell.acrossClue;\r\n          self._updateDOM();\r\n        }\r\n\r\n      }\r\n\r\n    });\r\n\r\n    //  Listen for keypress events.\r\n    cellElement.addEventListener(\"keypress\", function(event) {\r\n\r\n      //  We've just pressed a key that generates a char. In all\r\n      //  cases, we're going to overwrite by blatting the current \r\n      //  content. If the key is space, we suppress so we don't get\r\n      //  a space, then we always move to the next cell in the clue.\r\n      \r\n      //  No spaces in empty cells.\r\n      if(event.keyCode === 32) {\r\n        event.preventDefault();\r\n      }\r\n\r\n      //  Blat current content.\r\n      event.target.value = \"\";\r\n\r\n      //  Get cell data.\r\n      var cellElement = event.target.parentNode;\r\n      var cell = cellMap.getCell(cellElement);\r\n      var crossword = cell.crossword;\r\n      var clue = self.currentClue;\r\n\r\n      //  Sets the letter of a string.\r\n      function setLetter(source, index, newLetter) {\r\n        var sourceNormalised = source === null || source === undefined ? \"\" : source;\r\n        var result = \"\";\r\n        while(sourceNormalised.length <= index) sourceNormalised = sourceNormalised + \" \";\r\n        var seek = Math.max(index, sourceNormalised.length);\r\n        for(var i=0;i<seek;i++) {\r\n          result += i == index ? newLetter : sourceNormalised[i];\r\n        }\r\n        return result;\r\n      }\r\n\r\n      //  We need to update the answer.\r\n      var key = String.fromCharCode(event.keyCode);\r\n      if(cell.acrossClue) cell.acrossClue.answer = setLetter(cell.acrossClue.answer, cell.acrossClueLetterIndex, key);\r\n      if(cell.downClue) cell.downClue.answer = setLetter(cell.downClue.answer, cell.downClueLetterIndex, key);\r\n\r\n      //  Move to the next cell in the clue.\r\n      var currentIndex = cell.acrossClue === clue ? cell.acrossClueLetterIndex : cell.downClueLetterIndex;\r\n      var nextIndex = currentIndex + 1;\r\n      if(nextIndex < clue.cells.length) {\r\n        clue.cells[nextIndex].cellElement.querySelector('input').focus();\r\n      }\r\n\r\n    });\r\n\r\n    //  Listen for keyup events.\r\n    cellElement.addEventListener(\"keyup\", function(event) {\r\n      switch (event.keyCode) {\r\n        case 37: // left\r\n        \r\n          var cellElement = event.target.parentNode;\r\n          var cell = cellMap.getCell(cellElement);\r\n          var x = cell.x, y = cell.y;\r\n\r\n          //  If we can go left, go left.\r\n          if(cell.x > 0 && cell.crossword.cells[x-1][y].light === true) {\r\n            //  TODO: optimise with children[0]?\r\n            cellMap.getCellElement(cell.crossword.cells[x-1][y]).querySelector('input').focus();\r\n          }\r\n          break;\r\n        case 38: // up\r\n          var cellElement = event.target.parentNode;\r\n          var cell = cellMap.getCell(cellElement);\r\n          var x = cell.x, y = cell.y;\r\n\r\n          //  If we can go up, go up.\r\n          if(cell.y > 0 && cell.crossword.cells[x][y-1].light === true) {\r\n            //  TODO: optimise with children[0]?\r\n            cellMap.getCellElement(cell.crossword.cells[x][y-1]).querySelector('input').focus();\r\n          }\r\n          break;\r\n        case 39: // right\r\n          var cellElement = event.target.parentNode;\r\n          var cell = cellMap.getCell(cellElement);\r\n          var width = cell.crossword.width;\r\n          var x = cell.x, y = cell.y;\r\n\r\n          //  If we can go right, go right.\r\n          if(cell.x + 1 < width && cell.crossword.cells[x+1][y].light === true) {\r\n            //  TODO: optimise with children[0]?\r\n            cellMap.getCellElement(cell.crossword.cells[x+1][y]).querySelector('input').focus();\r\n          }\r\n          break;\r\n        case 40: // down\r\n          var cellElement = event.target.parentNode;\r\n          var cell = cellMap.getCell(cellElement);\r\n          var height = cell.crossword.height;\r\n          var x = cell.x, y = cell.y;\r\n\r\n          //  If we can go down, go down.\r\n          if(cell.y + 1 < height && cell.crossword.cells[x][y+1].light === true) {\r\n            //  TODO: optimise with children[0]?\r\n            cellMap.getCellElement(cell.crossword.cells[x][y+1]).querySelector('input').focus();\r\n          }\r\n          break;\r\n        case 9: // tab\r\n          //  todo\r\n          break;\r\n\r\n        default: // anything else...\r\n          //  todo\r\n          break;\r\n      }\r\n    });\r\n\r\n    return cellElement;\r\n  };\r\n\r\n  //  Updates the DOM based on the model, ensuring that the CSS\r\n  //  is correct for the state (i.e. the selected clue).\r\n  CrosswordDOM.prototype._updateDOM = function _updateDOM() {\r\n\r\n    //  TODO: pick a name - active, current or selected.\r\n    var activeClue = this.currentClue;\r\n    var crossword = this.crossword;\r\n\r\n    //  Deactivate all cells, except those which match the clue.\r\n    for(var x = 0; x < crossword.cells.length; x++) {\r\n      for(var y = 0; y < crossword.cells[x].length; y++) {\r\n        var cell = crossword.cells[x][y];\r\n        if(cell.light === true) { \r\n          if((cell.acrossClue === activeClue) || (cell.downClue === activeClue)) {\r\n            addClass(cellMap.getCellElement(cell).querySelector('input'), \"active\");\r\n          } else {\r\n            removeClass(cellMap.getCellElement(cell).querySelector('input'), \"active\");\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  //  Create a single global instance of a cell map.\r\n  var cellMap = new CellMap();\r\n\r\n  //  Define our public API.\r\n  CrosswordsJS.CrosswordDOM = CrosswordDOM;\r\n  return CrosswordsJS;\r\n\r\n})(CrosswordsJS || {}, window, document);"],"sourceRoot":"/source/"}